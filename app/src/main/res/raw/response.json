[
  {
    url: "https://api.github.com/repos/crashlytics/secureudid/issues/13",
    repository_url: "https://api.github.com/repos/crashlytics/secureudid",
    labels_url: "https://api.github.com/repos/crashlytics/secureudid/issues/13/labels{/name}",
    comments_url: "https://api.github.com/repos/crashlytics/secureudid/issues/13/comments",
    events_url: "https://api.github.com/repos/crashlytics/secureudid/issues/13/events",
    html_url: "https://github.com/crashlytics/secureudid/issues/13",
    id: 3923240,
    number: 13,
    title: "Not working with ARC",
    user: {
      login: "SaschaMoellering",
      id: 1321549,
      avatar_url: "https://avatars.githubusercontent.com/u/1321549?v=3",
      gravatar_id: "",
      url: "https://api.github.com/users/SaschaMoellering",
      html_url: "https://github.com/SaschaMoellering",
      followers_url: "https://api.github.com/users/SaschaMoellering/followers",
      following_url: "https://api.github.com/users/SaschaMoellering/following{/other_user}",
      gists_url: "https://api.github.com/users/SaschaMoellering/gists{/gist_id}",
      starred_url: "https://api.github.com/users/SaschaMoellering/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/SaschaMoellering/subscriptions",
      organizations_url: "https://api.github.com/users/SaschaMoellering/orgs",
      repos_url: "https://api.github.com/users/SaschaMoellering/repos",
      events_url: "https://api.github.com/users/SaschaMoellering/events{/privacy}",
      received_events_url: "https://api.github.com/users/SaschaMoellering/received_events",
      type: "User",
      site_admin: false
    },
    labels: [ ],
    state: "open",
    locked: false,
    assignee: null,
    assignees: [ ],
    milestone: null,
    comments: 10,
    created_at: "2012-04-02T09:18:15Z",
    updated_at: "2012-04-04T14:20:28Z",
    closed_at: null,
    body: "Hi, I tried to get the code running with ARC, so I changed the current code like this: CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault); identifier = CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, uuid)); CFRelease(uuid); But I get an EXC_BAD_ACCESS during runtime. Can you test your code with ARC? Best regards, Sascha"
  },
  {
    url: "https://api.github.com/repos/crashlytics/secureudid/issues/9",
    repository_url: "https://api.github.com/repos/crashlytics/secureudid",
    labels_url: "https://api.github.com/repos/crashlytics/secureudid/issues/9/labels{/name}",
    comments_url: "https://api.github.com/repos/crashlytics/secureudid/issues/9/comments",
    events_url: "https://api.github.com/repos/crashlytics/secureudid/issues/9/events",
    html_url: "https://github.com/crashlytics/secureudid/issues/9",
    id: 3849463,
    number: 9,
    title: "App runs opt-out code",
    user: {
      login: "silverdirectxer",
      id: 1583075,
      avatar_url: "https://avatars.githubusercontent.com/u/1583075?v=3",
      gravatar_id: "",
      url: "https://api.github.com/users/silverdirectxer",
      html_url: "https://github.com/silverdirectxer",
      followers_url: "https://api.github.com/users/silverdirectxer/followers",
      following_url: "https://api.github.com/users/silverdirectxer/following{/other_user}",
      gists_url: "https://api.github.com/users/silverdirectxer/gists{/gist_id}",
      starred_url: "https://api.github.com/users/silverdirectxer/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/silverdirectxer/subscriptions",
      organizations_url: "https://api.github.com/users/silverdirectxer/orgs",
      repos_url: "https://api.github.com/users/silverdirectxer/repos",
      events_url: "https://api.github.com/users/silverdirectxer/events{/privacy}",
      received_events_url: "https://api.github.com/users/silverdirectxer/received_events",
      type: "User",
      site_admin: false
    },
    labels: [ ],
    state: "open",
    locked: false,
    assignee: null,
    assignees: [ ],
    milestone: null,
    comments: 8,
    created_at: "2012-03-28T11:23:25Z",
    updated_at: "2012-03-29T13:00:22Z",
    closed_at: null,
    body: "It is said that the opt-out code will be provided in open source. What about if someone write an app that automatically runs the opt-out code? So all other apps that using secureudid for tracking will stop functioning too?"
  },
  {
    url: "https://api.github.com/repos/crashlytics/secureudid/issues/8",
    repository_url: "https://api.github.com/repos/crashlytics/secureudid",
    labels_url: "https://api.github.com/repos/crashlytics/secureudid/issues/8/labels{/name}",
    comments_url: "https://api.github.com/repos/crashlytics/secureudid/issues/8/comments",
    events_url: "https://api.github.com/repos/crashlytics/secureudid/issues/8/events",
    html_url: "https://github.com/crashlytics/secureudid/issues/8",
    id: 3846774,
    number: 8,
    title: "Security of salt needs clarifying",
    user: {
      login: "mattjgalloway",
      id: 753010,
      avatar_url: "https://avatars.githubusercontent.com/u/753010?v=3",
      gravatar_id: "",
      url: "https://api.github.com/users/mattjgalloway",
      html_url: "https://github.com/mattjgalloway",
      followers_url: "https://api.github.com/users/mattjgalloway/followers",
      following_url: "https://api.github.com/users/mattjgalloway/following{/other_user}",
      gists_url: "https://api.github.com/users/mattjgalloway/gists{/gist_id}",
      starred_url: "https://api.github.com/users/mattjgalloway/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/mattjgalloway/subscriptions",
      organizations_url: "https://api.github.com/users/mattjgalloway/orgs",
      repos_url: "https://api.github.com/users/mattjgalloway/repos",
      events_url: "https://api.github.com/users/mattjgalloway/events{/privacy}",
      received_events_url: "https://api.github.com/users/mattjgalloway/received_events",
      type: "User",
      site_admin: false
    },
    labels: [ ],
    state: "open",
    locked: false,
    assignee: null,
    assignees: [ ],
    milestone: null,
    comments: 14,
    created_at: "2012-03-28T08:49:50Z",
    updated_at: "2012-04-04T16:50:27Z",
    closed_at: null,
    body: "WIthin the example you say to do something like this: ```objective-c NSString *salt = @"superSecretCodeHere!@##%#$#%$^" ``` And then pass that into `UDIDForDomain:salt:`. The fact that you're saying `superSecretCodeHere` worries me. That will not be secret at all and might lead to people using sensitive strings here, perhaps a password that they use elsewhere thinking that it'll be safe when it really isn't. I think the documentation should be clarified to state that it's not really "super secret" at all but is rather just another part of the key used to en/decrypt the data stored on the pasteboard."
  },
  {
    url: "https://api.github.com/repos/crashlytics/secureudid/issues/5",
    repository_url: "https://api.github.com/repos/crashlytics/secureudid",
    labels_url: "https://api.github.com/repos/crashlytics/secureudid/issues/5/labels{/name}",
    comments_url: "https://api.github.com/repos/crashlytics/secureudid/issues/5/comments",
    events_url: "https://api.github.com/repos/crashlytics/secureudid/issues/5/events",
    html_url: "https://github.com/crashlytics/secureudid/issues/5",
    id: 3841131,
    number: 5,
    title: "Does not appear to support device differentiation.",
    user: {
      login: "terrillt",
      id: 204817,
      avatar_url: "https://avatars.githubusercontent.com/u/204817?v=3",
      gravatar_id: "",
      url: "https://api.github.com/users/terrillt",
      html_url: "https://github.com/terrillt",
      followers_url: "https://api.github.com/users/terrillt/followers",
      following_url: "https://api.github.com/users/terrillt/following{/other_user}",
      gists_url: "https://api.github.com/users/terrillt/gists{/gist_id}",
      starred_url: "https://api.github.com/users/terrillt/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/terrillt/subscriptions",
      organizations_url: "https://api.github.com/users/terrillt/orgs",
      repos_url: "https://api.github.com/users/terrillt/repos",
      events_url: "https://api.github.com/users/terrillt/events{/privacy}",
      received_events_url: "https://api.github.com/users/terrillt/received_events",
      type: "User",
      site_admin: false
    },
    labels: [ ],
    state: "open",
    locked: false,
    assignee: null,
    assignees: [ ],
    milestone: null,
    comments: 14,
    created_at: "2012-03-27T22:02:23Z",
    updated_at: "2013-03-05T16:54:33Z",
    closed_at: null,
    body: "Correct me if I am wrong, but the implementation uses CFUUIDCreate to create the actual UDID (which was Apple's default suggestion for developers to deal with the deprecation of UDIDs). However, this only results in generating an ID that is unique to your application (or family of applications) without any way to tie it to a particular device. This isn't device differentiation. A user can back up their Device #1 to iTunes and then restore the backup onto Device #2. (In fact, if they choose to encrypt their backup, they will even transfer their Keychain to the new device.) The user can now run the app on both Device #1 and Device #2 and the developer's server will be unable to recognize the difference between the two apps. This can create sync problems at the very least. I understand the privacy concerns raised by having device differentiation and this solution is trying to solve for those problems, but there are applications that absolutely require device differentiation. Implementing Digital Rights Management is just the first off the top of my head but I am sure there are other use cases."
  },
  {
    url: "https://api.github.com/repos/crashlytics/secureudid/issues/4",
    repository_url: "https://api.github.com/repos/crashlytics/secureudid",
    labels_url: "https://api.github.com/repos/crashlytics/secureudid/issues/4/labels{/name}",
    comments_url: "https://api.github.com/repos/crashlytics/secureudid/issues/4/comments",
    events_url: "https://api.github.com/repos/crashlytics/secureudid/issues/4/events",
    html_url: "https://github.com/crashlytics/secureudid/issues/4",
    id: 3840910,
    number: 4,
    title: "Why are you using UIPasteboard instead of the Security framework?",
    user: {
      login: "terrillt",
      id: 204817,
      avatar_url: "https://avatars.githubusercontent.com/u/204817?v=3",
      gravatar_id: "",
      url: "https://api.github.com/users/terrillt",
      html_url: "https://github.com/terrillt",
      followers_url: "https://api.github.com/users/terrillt/followers",
      following_url: "https://api.github.com/users/terrillt/following{/other_user}",
      gists_url: "https://api.github.com/users/terrillt/gists{/gist_id}",
      starred_url: "https://api.github.com/users/terrillt/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/terrillt/subscriptions",
      organizations_url: "https://api.github.com/users/terrillt/orgs",
      repos_url: "https://api.github.com/users/terrillt/repos",
      events_url: "https://api.github.com/users/terrillt/events{/privacy}",
      received_events_url: "https://api.github.com/users/terrillt/received_events",
      type: "User",
      site_admin: false
    },
    labels: [ ],
    state: "open",
    locked: false,
    assignee: null,
    assignees: [ ],
    milestone: null,
    comments: 16,
    created_at: "2012-03-27T21:48:19Z",
    updated_at: "2013-03-25T13:18:10Z",
    closed_at: null,
    body: "Given the stated aim of allowing only developers to access the UDID over their own stable of applications, why aren't you using the security framework to save data to the keychain for the underlying implementation? It's already a secure storage area where foreign apps can't even access your data (as opposed to just being unable to decrypt it), and you can use it across a family of apps, assuming you set up your apps from the start with a common Bundle Seed ID."
  },
  {
    url: "https://api.github.com/repos/crashlytics/secureudid/issues/1",
    repository_url: "https://api.github.com/repos/crashlytics/secureudid",
    labels_url: "https://api.github.com/repos/crashlytics/secureudid/issues/1/labels{/name}",
    comments_url: "https://api.github.com/repos/crashlytics/secureudid/issues/1/comments",
    events_url: "https://api.github.com/repos/crashlytics/secureudid/issues/1/events",
    html_url: "https://github.com/crashlytics/secureudid/issues/1",
    id: 3833379,
    number: 1,
    title: "Possibility of compromising the SecureUDID",
    user: {
      login: "grantland",
      id: 277030,
      avatar_url: "https://avatars.githubusercontent.com/u/277030?v=3",
      gravatar_id: "",
      url: "https://api.github.com/users/grantland",
      html_url: "https://github.com/grantland",
      followers_url: "https://api.github.com/users/grantland/followers",
      following_url: "https://api.github.com/users/grantland/following{/other_user}",
      gists_url: "https://api.github.com/users/grantland/gists{/gist_id}",
      starred_url: "https://api.github.com/users/grantland/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/grantland/subscriptions",
      organizations_url: "https://api.github.com/users/grantland/orgs",
      repos_url: "https://api.github.com/users/grantland/repos",
      events_url: "https://api.github.com/users/grantland/events{/privacy}",
      received_events_url: "https://api.github.com/users/grantland/received_events",
      type: "User",
      site_admin: false
    },
    labels: [ ],
    state: "open",
    locked: false,
    assignee: null,
    assignees: [ ],
    milestone: null,
    comments: 2,
    created_at: "2012-03-27T18:41:41Z",
    updated_at: "2012-03-27T19:27:22Z",
    closed_at: null,
    body: "It seems that both SecureUDID and OpenUDID have a possibility of a third party modifying the base UID that both libraries rely on and compromising the SecureUDID/OpenUDID. Basically, a third party could write a pasteboard with the same format and with the same naming schema. The next time a real SecureUDID or OpenUDID checks for the UID, it would see the UID that the third party wrote as the "newest" and overwrite their pasteboard UID with that one. Each app thereafter would update their pasteboard until the the malicious UID completely replaces the original SecureUDID/OpenUDID. A interesting solution would be for an app to make their own pasteboard the priority and update the modified date every time. This would minimize the probability of a third party rewriting the base UID, but only if a previously installed SecureUDID/OpenUDID app ran before a new SecureUDID/OpenUDID app was installed and run. The best solution might be providing a closed source library that uses a signature to sign and validate valid pasteboards."
  }
]